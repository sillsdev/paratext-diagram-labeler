name: Upload Release to Website

# This workflow downloads release assets from GitHub and uploads them to the SIL software website.
# It generates .download_info metadata files for each installer package.
#
# Required Repository Variables (Settings → Secrets and variables → Actions → Variables):
#   PROJECT_NAME: Display name of the project (e.g., "Paratext Diagram Labeler")
#   PROJECT_FOLDER: Folder name for downloads (e.g., "labeler")
#   SFTP_HOST: SFTP server hostname (e.g., "software.sil.org")
#   SFTP_TARGET_DIR: Base directory path without project folder (e.g., "/var/www/virtual/software.sil.org/htdocs/downloads/r")
#   DOWNLOAD_BASE_URL: Public download URL without project folder (e.g., "https://software.sil.org/downloads/r")
#
# Required Repository Secrets (Settings → Secrets and variables → Actions → Secrets):
#   SFTP_USERNAME: SSH username for SFTP authentication
#   SFTP_PRIVATE_KEY: SSH private key for SFTP authentication
#
# Files are uploaded to: {SFTP_TARGET_DIR}/{PROJECT_FOLDER}/
# Download URLs become: {DOWNLOAD_BASE_URL}/{PROJECT_FOLDER}/{filename}

on:
  release:
    types: [published, edited]
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Release tag to upload (e.g., v0.1.5)'
        required: true
        type: string

jobs:
  upload:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set release tag
        id: release_tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "tag=${{ inputs.tag_name }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Download all release assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release download ${{ steps.release_tag.outputs.tag }} --dir ./dist

      - name: Extract version from tag
        id: version
        run: |
          TAG="${{ steps.release_tag.outputs.tag }}"
          VERSION="${TAG#v}"  # Remove 'v' prefix if present
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Generate .download_info files for all installers
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          DATE=$(date -u '+%Y-%m-%d')
          BASE_URL="${{ vars.DOWNLOAD_BASE_URL }}/${{ vars.PROJECT_FOLDER }}"
          if [ -z "${{ vars.DOWNLOAD_BASE_URL }}" ]; then
            BASE_URL="https://${{ vars.SFTP_HOST }}/downloads/r/${{ vars.PROJECT_FOLDER }}"
          fi

          # Function to determine platform, type, platform_version, and architecture from filename
          get_platform_info() {
            local filename="$1"
            local platform=""
            local type=""
            local platform_version=""
            local architecture=""
            
            case "$filename" in
              *.exe)
                platform="win"
                type="exe"
                platform_version="10+"
                architecture=""
                ;;
              *.deb)
                platform="linux"
                type="deb"
                platform_version=""
                architecture=""
                ;;
              *.AppImage)
                platform="linux"
                type="AppImage"
                platform_version=""
                architecture=""
                ;;
              *.dmg)
                platform="mac"
                type="dmg"
                platform_version=""
                # Leave architecture empty - either universal binary or use x86_64 if Intel-only
                # Per spec, only x86_64 and x86_32 are allowed values
                architecture=""
                ;;
            esac
            
            echo "$platform|$type|$platform_version|$architecture"
          }

          # Process each installer file (exclude .tar.gz and .zip source archives)
          find ./dist -maxdepth 1 -type f \( -name "*.exe" -o -name "*.deb" -o -name "*.AppImage" -o -name "*.dmg" \) | while read FILE; do
            FILENAME=$(basename "$FILE")
            SIZE=$(stat -c%s "$FILE")
            MD5=$(md5sum "$FILE" | cut -d' ' -f1)
            
            # Get platform, type, platform_version, and architecture
            PLATFORM_INFO=$(get_platform_info "$FILENAME")
            PLATFORM=$(echo "$PLATFORM_INFO" | cut -d'|' -f1)
            TYPE=$(echo "$PLATFORM_INFO" | cut -d'|' -f2)
            PLATFORM_VERSION=$(echo "$PLATFORM_INFO" | cut -d'|' -f3)
            ARCHITECTURE=$(echo "$PLATFORM_INFO" | cut -d'|' -f4)
            
            # Skip if we couldn't determine platform
            [ -z "$PLATFORM" ] && continue
            
            # Generate JSON
            printf '{\n' > "./dist/${FILENAME}.download_info"
            printf '  "name": "${{ vars.PROJECT_NAME }}",\n' >> "./dist/${FILENAME}.download_info"
            printf '  "version": "%s",\n' "$VERSION" >> "./dist/${FILENAME}.download_info"
            printf '  "date": "%s",\n' "$DATE" >> "./dist/${FILENAME}.download_info"
            printf '  "platform": "%s",\n' "$PLATFORM" >> "./dist/${FILENAME}.download_info"
            printf '  "platform_version": "%s",\n' "$PLATFORM_VERSION" >> "./dist/${FILENAME}.download_info"
            printf '  "architecture": "%s",\n' "$ARCHITECTURE" >> "./dist/${FILENAME}.download_info"
            printf '  "stability": "stable",\n' >> "./dist/${FILENAME}.download_info"
            printf '  "file": "%s",\n' "$FILENAME" >> "./dist/${FILENAME}.download_info"
            printf '  "md5": "%s",\n' "$MD5" >> "./dist/${FILENAME}.download_info"
            printf '  "type": "%s",\n' "$TYPE" >> "./dist/${FILENAME}.download_info"
            printf '  "build": ""\n' >> "./dist/${FILENAME}.download_info"
            printf '}\n' >> "./dist/${FILENAME}.download_info"
            
            echo "Generated ${FILENAME}.download_info for $PLATFORM ($TYPE, platform_version: $PLATFORM_VERSION, arch: $ARCHITECTURE)"
          done
          
          echo ""
          echo "All generated .download_info files:"
          ls -l ./dist/*.download_info

      - name: List all files to upload
        run: |
          echo "Files in dist directory:"
          ls -lh ./dist/

      - name: Upload all installers + .download_info files via SCP
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ vars.SFTP_HOST }}
          username: ${{ secrets.SFTP_USERNAME }}
          key: ${{ secrets.SFTP_PRIVATE_KEY }}
          port: 22
          source: "dist/*"
          target: ${{ vars.SFTP_TARGET_DIR }}/${{ vars.PROJECT_FOLDER }}
          strip_components: 1
